#include "type.h"
#include "stdio.h"
#include "const.h"
#include "protect.h"
#include "string.h"
#include "fs.h"
#include "proc.h"
#include "tty.h"
#include "console.h"
#include "global.h"
#include "keyboard.h"
#include "keymap.h"
#include "proto.h"

PRIVATE struct kb_inbuf kb_in;
PRIVATE int code_with_E0;
PRIVATE int shift_l;	/* left shift state */
PRIVATE int shift_r;	/* right shift state */
PRIVATE int alt_l;		/* left alt state */
PRIVATE int alt_r;		/* right alt state */
PRIVATE int ctrl_l;		/* left ctrl state */
PRIVATE int ctrl_r;		/* right ctrl state */
PRIVATE int caps_lock;	/* Caps Lcok */
PRIVATE int num_lock;	/* Num Lock */
PRIVATE int scroll_lock;	/* Scroll Lock */
PRIVATE int column;

PRIVATE u8 get_byte_from_kb_buf();
PRIVATE void set_leds();
PRIVATE void kb_wait();
PRIVAET void kb_ack();

/**
 * keyboard_handler
 * 
 * <Ring 0> Handles the interrupts generated by the keyboard controller.
 * 
 * @param irq: The IRQ corresponding to the keyboard, unused here.
 *
 */
PUBLIC void keyboard_handler(int irq)
{
	u8 scan_code = in_byte(KB_DATA);

	if(kb_in.count < KB_IN_BYTES) {
		*(kb_in.p_head) = scan_code;
		kb_in.p_head++;
		if(kb_in.p_head == kb_in.buf + KB_IN_BYTES)
			kb_in.p_head = kb_in.buf;
		kb_in.count++;
	}

#if 0
	if(!(scan_code & FLAG_BREAK) && keymap[(scan_code & 0x7F) * MAP_COLS] == F12) {
		printl("================================\n");
		struct proc* p;
		for(p = &FIRST_PROC; p <= &LAST_PROC; p++) {
			if(p->p_flags == FREE_SLOT)
				continue;
			int from = p->p_recvfrom;
			int to = p->p_sendto;
			printl("csip=%x:%x, tks=%x, f=%x(%s), t=%x(%s), him=%x, %s(%d)\n", \
				p->regs.cs, p->regs.eip, p->ticks, from, from < NR_PROCS ? \
				proc_table[from].name : (from == ANY ? "ANY" : (from == NO_TASK ? "NO_TASK" : "_?_")), \
				to, to < NR_PROCS ? proc_table[to].name : (to == ANY ? "ANY" : \
				(to == NO_TASK ? "NO_TASK" : "_?_")), p->has_int_msg, p->name, proc2pid(p));
		}
		printl("================================\n");
	}
#endif	
	key_pressed = 1;
}

